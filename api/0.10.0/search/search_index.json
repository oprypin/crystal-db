{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"crystal-db # Common db api for crystal. You will need to have a specific driver to access a database. SQLite MySQL PostgreSQL Cassandra Installation # If you are creating a shard that will work with any driver, then add crystal-db as a dependency in shard.yml : dependencies : db : github : crystal-lang/crystal-db If you are creating an application that will work with some specific driver(s), then add them in shard.yml : dependencies : sqlite3 : github : crystal-lang/crystal-sqlite3 crystal-db itself will be a nested dependency if drivers are included. Note: Multiple drivers can be included in the same application. Documentation # Latest API Crystal book Usage # This shard only provides an abstract database API. In order to use it, a specific driver for the intended database has to be required as well: The following example uses SQLite where ? indicates the arguments. If PostgreSQL is used $1 , $2 , etc. should be used. crystal-db does not interpret the statements. require \"db\" require \"sqlite3\" DB . open \"sqlite3:./file.db\" do | db | # When using the pg driver, use $1, $2, etc. instead of ? db . exec \"create table contacts (name text, age integer)\" db . exec \"insert into contacts values (?, ?)\" , \"John Doe\" , 30 args = [] of DB :: Any args << \"Sarah\" args << 33 db . exec \"insert into contacts values (?, ?)\" , args : args puts \"max age:\" puts db . scalar \"select max(age) from contacts\" # => 33 puts \"contacts:\" db . query \"select name, age from contacts order by age desc\" do | rs | puts \" #{ rs . column_name ( 0 ) } ( #{ rs . column_name ( 1 ) } )\" # => name (age) rs . each do puts \" #{ rs . read ( String ) } ( #{ rs . read ( Int32 ) } )\" # => Sarah (33) # => John Doe (30) end end end Roadmap # Issues not yet addressed: Support non prepared statements. #25 Time data type. (implementation details depends on actual drivers) Data type extensibility. Allow each driver to extend the data types allowed. Transactions & nested transactions. #27 Connection pool. Logging Direct access to IO to avoid memory allocation for blobs. Contributing # Fork it ( https://github.com/crystal-lang/crystal-db/fork ) Create your feature branch (git checkout -b my-new-feature) Commit your changes (git commit -am 'Add some feature') Push to the branch (git push origin my-new-feature) Create a new Pull Request Contributors # bcardiff Brian J. Cardiff - creator, maintainer","title":"Index"},{"location":"index.html#crystal-db","text":"Common db api for crystal. You will need to have a specific driver to access a database. SQLite MySQL PostgreSQL Cassandra","title":"crystal-db"},{"location":"index.html#installation","text":"If you are creating a shard that will work with any driver, then add crystal-db as a dependency in shard.yml : dependencies : db : github : crystal-lang/crystal-db If you are creating an application that will work with some specific driver(s), then add them in shard.yml : dependencies : sqlite3 : github : crystal-lang/crystal-sqlite3 crystal-db itself will be a nested dependency if drivers are included. Note: Multiple drivers can be included in the same application.","title":"Installation"},{"location":"index.html#documentation","text":"Latest API Crystal book","title":"Documentation"},{"location":"index.html#usage","text":"This shard only provides an abstract database API. In order to use it, a specific driver for the intended database has to be required as well: The following example uses SQLite where ? indicates the arguments. If PostgreSQL is used $1 , $2 , etc. should be used. crystal-db does not interpret the statements. require \"db\" require \"sqlite3\" DB . open \"sqlite3:./file.db\" do | db | # When using the pg driver, use $1, $2, etc. instead of ? db . exec \"create table contacts (name text, age integer)\" db . exec \"insert into contacts values (?, ?)\" , \"John Doe\" , 30 args = [] of DB :: Any args << \"Sarah\" args << 33 db . exec \"insert into contacts values (?, ?)\" , args : args puts \"max age:\" puts db . scalar \"select max(age) from contacts\" # => 33 puts \"contacts:\" db . query \"select name, age from contacts order by age desc\" do | rs | puts \" #{ rs . column_name ( 0 ) } ( #{ rs . column_name ( 1 ) } )\" # => name (age) rs . each do puts \" #{ rs . read ( String ) } ( #{ rs . read ( Int32 ) } )\" # => Sarah (33) # => John Doe (30) end end end","title":"Usage"},{"location":"index.html#roadmap","text":"Issues not yet addressed: Support non prepared statements. #25 Time data type. (implementation details depends on actual drivers) Data type extensibility. Allow each driver to extend the data types allowed. Transactions & nested transactions. #27 Connection pool. Logging Direct access to IO to avoid memory allocation for blobs.","title":"Roadmap"},{"location":"index.html#contributing","text":"Fork it ( https://github.com/crystal-lang/crystal-db/fork ) Create your feature branch (git checkout -b my-new-feature) Commit your changes (git commit -am 'Add some feature') Push to the branch (git push origin my-new-feature) Create a new Pull Request","title":"Contributing"},{"location":"index.html#contributors","text":"bcardiff Brian J. Cardiff - creator, maintainer","title":"Contributors"},{"location":"DB.html","text":"module DB # The DB module is a unified interface for database access. Individual database systems are supported by specific database driver shards. Available drivers include: crystal-lang/crystal-sqlite3 for SQLite crystal-lang/crystal-mysql for MySQL and MariaDB will/crystal-pg for PostgreSQL kaukas/crystal-cassandra for Cassandra For basic instructions on implementing a new database driver, check Driver and the existing drivers. DB manages a connection pool. The connection pool can be configured by query parameters to the connection URI as described in Database . Usage # Assuming crystal-sqlite3 is included a SQLite3 database can be opened with #open . db = DB . open \"sqlite3:./path/to/db/file.db\" db . close If a block is given to #open the database is closed automatically DB . open \"sqlite3:./file.db\" do | db | # work with db end # db is closed In the code above db is a Database . Methods available for querying it are described in QueryMethods . Three kind of statements can be performed: 1. Database#exec waits no response from the database. 2. Database#scalar reads a single value of the response. 3. Database#query returns a ResultSet that allows iteration over the rows in the response and column information. All of the above methods allows parametrised query. Either positional or named arguments. Check a full working version: The following example uses SQLite where ? indicates the arguments. If PostgreSQL is used $1 , $2 , etc. should be used. crystal-db does not interpret the statements. require \"db\" require \"sqlite3\" DB . open \"sqlite3:./file.db\" do | db | # When using the pg driver, use $1, $2, etc. instead of ? db . exec \"create table contacts (name text, age integer)\" db . exec \"insert into contacts values (?, ?)\" , \"John Doe\" , 30 args = [] of DB :: Any args << \"Sarah\" args << 33 db . exec \"insert into contacts values (?, ?)\" , args : args puts \"max age:\" puts db . scalar \"select max(age) from contacts\" # => 33 puts \"contacts:\" db . query \"select name, age from contacts order by age desc\" do | rs | puts \" #{ rs . column_name ( 0 ) } ( #{ rs . column_name ( 1 ) } )\" # => name (age) rs . each do puts \" #{ rs . read ( String ) } ( #{ rs . read ( Int32 ) } )\" # => Sarah (33) # => John Doe (30) end end end Constants # Log = :: Log . for ( self ) # TYPES = [ Nil , String , Bool , Int32 , Int64 , Float32 , Float64 , Time , Bytes ] # Types supported to interface with database driver. These can be used in any ResultSet#read or any Database#query related method to be used as query parameters VERSION = \"0.10.0\" # Class methods # .connect ( uri : URI | String ) # Opens a connection using the specified uri . The scheme of the uri determines the driver to use. Returned connection must be closed by Connection#close . If a block is used the connection is yielded and closed automatically. View source .connect # Opens a connection using the specified uri . The scheme of the uri determines the driver to use. Returned connection must be closed by Connection#close . If a block is used the connection is yielded and closed automatically. View source .open ( uri : URI | String ) # Creates a Database pool and opens initial connection(s) as specified in the connection uri . Use DB#connect to open a single connection. The scheme of the uri determines the driver to use. Connection parameters such as hostname, user, database name, etc. are specified according to each database driver's specific format. The returned database must be closed by Database#close . View source .open # Same as #open but the database is yielded and closed automatically at the end of the block. View source .register_driver ( driver_name , driver_class : Driver . class ) # Registers a driver class for a given driver_name . Should be called by drivers implementors only. View source Macros # mapping ( properties , strict = true ) # The DB.mapping macro defines how an object is built from a ResultSet . It takes hash literal as argument, in which attributes and types are defined. Once defined, ResultSet#read(t) populates properties of the class from the ResultSet . require \"db\" class Employee DB . mapping ({ title : String , name : String , }) end employees = Employee . from_rs ( db . query ( \"SELECT title, name FROM employees\" )) employees [ 0 ]. title # => \"Manager\" employees [ 0 ]. name # => \"John\" Attributes not mapped with DB.mapping are not defined as properties. Also, missing attributes raise a DB::MappingException . You can also define attributes for each property. class Employee DB . mapping ({ title : String , name : { type : String , nilable : true , key : \"firstname\" , }, }) end Available attributes: type (required) defines its type. In the example above, title: String is a shortcut to title: {type: String} . nilable defines if a property can be a Nil . default : value to use if the property is missing in the result set, or if it's null and nilable was not set to true . If the default value creates a new instance of an object (for example [1, 2, 3] or SomeObject.new ), a different instance will be used each time a row is parsed. key defines which column to read from a ResultSet . It defaults to the name of the property. converter takes an alternate type for parsing. It requires a #from_rs method in that class, and returns an instance of the given type. The mapping also automatically defines Crystal properties (getters and setters) for each of the keys. It doesn't define a constructor accepting those arguments, but you can provide an overload. The macro basically defines a constructor accepting a ResultSet that reads from it and initializes this type's instance variables. This macro also declares instance variables of the types given in the mapping. View source mapping ( ** properties ) # View source","title":"DB module"},{"location":"DB.html#DB","text":"The DB module is a unified interface for database access. Individual database systems are supported by specific database driver shards. Available drivers include: crystal-lang/crystal-sqlite3 for SQLite crystal-lang/crystal-mysql for MySQL and MariaDB will/crystal-pg for PostgreSQL kaukas/crystal-cassandra for Cassandra For basic instructions on implementing a new database driver, check Driver and the existing drivers. DB manages a connection pool. The connection pool can be configured by query parameters to the connection URI as described in Database .","title":"DB"},{"location":"DB.html#DB--usage","text":"Assuming crystal-sqlite3 is included a SQLite3 database can be opened with #open . db = DB . open \"sqlite3:./path/to/db/file.db\" db . close If a block is given to #open the database is closed automatically DB . open \"sqlite3:./file.db\" do | db | # work with db end # db is closed In the code above db is a Database . Methods available for querying it are described in QueryMethods . Three kind of statements can be performed: 1. Database#exec waits no response from the database. 2. Database#scalar reads a single value of the response. 3. Database#query returns a ResultSet that allows iteration over the rows in the response and column information. All of the above methods allows parametrised query. Either positional or named arguments. Check a full working version: The following example uses SQLite where ? indicates the arguments. If PostgreSQL is used $1 , $2 , etc. should be used. crystal-db does not interpret the statements. require \"db\" require \"sqlite3\" DB . open \"sqlite3:./file.db\" do | db | # When using the pg driver, use $1, $2, etc. instead of ? db . exec \"create table contacts (name text, age integer)\" db . exec \"insert into contacts values (?, ?)\" , \"John Doe\" , 30 args = [] of DB :: Any args << \"Sarah\" args << 33 db . exec \"insert into contacts values (?, ?)\" , args : args puts \"max age:\" puts db . scalar \"select max(age) from contacts\" # => 33 puts \"contacts:\" db . query \"select name, age from contacts order by age desc\" do | rs | puts \" #{ rs . column_name ( 0 ) } ( #{ rs . column_name ( 1 ) } )\" # => name (age) rs . each do puts \" #{ rs . read ( String ) } ( #{ rs . read ( Int32 ) } )\" # => Sarah (33) # => John Doe (30) end end end","title":"Usage"},{"location":"DB.html#DB-constants","text":"","title":"Constants"},{"location":"DB.html#DB::Log","text":"","title":"Log"},{"location":"DB.html#DB::TYPES","text":"Types supported to interface with database driver. These can be used in any ResultSet#read or any Database#query related method to be used as query parameters","title":"TYPES"},{"location":"DB.html#DB::VERSION","text":"","title":"VERSION"},{"location":"DB.html#DB-class-methods","text":"","title":"Class methods"},{"location":"DB.html#DB.connect(uri)","text":"Opens a connection using the specified uri . The scheme of the uri determines the driver to use. Returned connection must be closed by Connection#close . If a block is used the connection is yielded and closed automatically. View source","title":".connect"},{"location":"DB.html#DB.open(uri)","text":"Creates a Database pool and opens initial connection(s) as specified in the connection uri . Use DB#connect to open a single connection. The scheme of the uri determines the driver to use. Connection parameters such as hostname, user, database name, etc. are specified according to each database driver's specific format. The returned database must be closed by Database#close . View source","title":".open"},{"location":"DB.html#DB.register_driver(driver_name,driver_class)","text":"Registers a driver class for a given driver_name . Should be called by drivers implementors only. View source","title":".register_driver"},{"location":"DB.html#DB-macros","text":"","title":"Macros"},{"location":"DB.html#DB:mapping(properties,strict)","text":"The DB.mapping macro defines how an object is built from a ResultSet . It takes hash literal as argument, in which attributes and types are defined. Once defined, ResultSet#read(t) populates properties of the class from the ResultSet . require \"db\" class Employee DB . mapping ({ title : String , name : String , }) end employees = Employee . from_rs ( db . query ( \"SELECT title, name FROM employees\" )) employees [ 0 ]. title # => \"Manager\" employees [ 0 ]. name # => \"John\" Attributes not mapped with DB.mapping are not defined as properties. Also, missing attributes raise a DB::MappingException . You can also define attributes for each property. class Employee DB . mapping ({ title : String , name : { type : String , nilable : true , key : \"firstname\" , }, }) end Available attributes: type (required) defines its type. In the example above, title: String is a shortcut to title: {type: String} . nilable defines if a property can be a Nil . default : value to use if the property is missing in the result set, or if it's null and nilable was not set to true . If the default value creates a new instance of an object (for example [1, 2, 3] or SomeObject.new ), a different instance will be used each time a row is parsed. key defines which column to read from a ResultSet . It defaults to the name of the property. converter takes an alternate type for parsing. It requires a #from_rs method in that class, and returns an instance of the given type. The mapping also automatically defines Crystal properties (getters and setters) for each of the keys. It doesn't define a constructor accepting those arguments, but you can provide an overload. The macro basically defines a constructor accepting a ResultSet that reads from it and initializes this type's instance variables. This macro also declares instance variables of the types given in the mapping. View source","title":"mapping"},{"location":"SUMMARY.html","text":"DB module Connection & session Database ConnectionContext Connection Pool Stats SessionMethods PreparedQuery UnpreparedQuery Transaction Transaction TopLevelTransaction SavePointTransaction BeginTransaction QueryMethods ExecResult ResultSet Statement Statement PoolStatement PoolUnpreparedStatement PoolPreparedStatement StatementMethods Driver Driver DriverSpecs ColumnDef MetadataValueConverter Serialization Serializable NonStrict Field Mappable Miscellaneous Any StringKeyCache Disposable Errors Error NoResultsError Rollback MappingException PoolResourceLost ConnectionLost PoolResourceRefused ConnectionRefused PoolRetryAttemptsExceeded PoolTimeout","title":"SUMMARY"},{"location":"DB/Any.html","text":"alias DB::Any # Alias definition Bool | Float32 | Float64 | Int32 | Int64 | Slice ( UInt8 ) | String | Time | Nil","title":"Any"},{"location":"DB/Any.html#DB::Any","text":"","title":"Any"},{"location":"DB/BeginTransaction.html","text":"module DB::BeginTransaction # Direct including types DB::Connection DB::Transaction Methods # abstract #begin_transaction : Transaction # Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source #transaction # yields a transaction from the current context. Query the database through Transaction#connection object. If an exception is thrown within the block a rollback is performed. The exception thrown is bubbled unless it is a DB::Rollback . From the yielded object Transaction#commit or Transaction#rollback can be called explicitly. View source","title":"BeginTransaction"},{"location":"DB/BeginTransaction.html#DB::BeginTransaction","text":"","title":"BeginTransaction"},{"location":"DB/BeginTransaction.html#DB::BeginTransaction-methods","text":"","title":"Methods"},{"location":"DB/BeginTransaction.html#DB::BeginTransaction#begin_transaction","text":"Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source","title":"#begin_transaction"},{"location":"DB/BeginTransaction.html#DB::BeginTransaction#transaction(&)","text":"yields a transaction from the current context. Query the database through Transaction#connection object. If an exception is thrown within the block a rollback is performed. The exception thrown is bubbled unless it is a DB::Rollback . From the yielded object Transaction#commit or Transaction#rollback can be called explicitly. View source","title":"#transaction"},{"location":"DB/Connection.html","text":"abstract class DB::Connection inherits Reference # Database driver implementors must subclass Connection . Represents one active connection to a database. Users should never instantiate a Connection manually. Use DB#open or Database#connection . Refer to QueryMethods for documentation about querying the database through this connection. Note to implementors # The connection must be initialized in #initialize and closed in #do_close . Override #build_prepared_statement method in order to return a prepared Statement to allow querying. Override #build_unprepared_statement method in order to return a unprepared Statement to allow querying. See also Statement to define how the statements are executed. If at any give moment the connection is lost a DB::ConnectionLost should be raised. This will allow the connection pool to try to reconnect or use another connection if available. Included modules DB::BeginTransaction DB::Disposable DB::SessionMethods Class methods # .new ( context : ConnectionContext ) # View source Methods # #begin_transaction : Transaction # Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source #prepared_statements? : Bool # Returns whether by default the statements should be prepared or not. View source #release # return this connection to the pool managed by the database. Should be used only if the connection was obtained by Database#checkout . View source","title":"Connection"},{"location":"DB/Connection.html#DB::Connection","text":"Database driver implementors must subclass Connection . Represents one active connection to a database. Users should never instantiate a Connection manually. Use DB#open or Database#connection . Refer to QueryMethods for documentation about querying the database through this connection.","title":"Connection"},{"location":"DB/Connection.html#DB::Connection--note-to-implementors","text":"The connection must be initialized in #initialize and closed in #do_close . Override #build_prepared_statement method in order to return a prepared Statement to allow querying. Override #build_unprepared_statement method in order to return a unprepared Statement to allow querying. See also Statement to define how the statements are executed. If at any give moment the connection is lost a DB::ConnectionLost should be raised. This will allow the connection pool to try to reconnect or use another connection if available.","title":"Note to implementors"},{"location":"DB/Connection.html#DB::Connection-class-methods","text":"","title":"Class methods"},{"location":"DB/Connection.html#DB::Connection.new(context)","text":"View source","title":".new"},{"location":"DB/Connection.html#DB::Connection-methods","text":"","title":"Methods"},{"location":"DB/Connection.html#DB::Connection#begin_transaction","text":"Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source","title":"#begin_transaction"},{"location":"DB/Connection.html#DB::Connection#prepared_statements?","text":"Returns whether by default the statements should be prepared or not. View source","title":"#prepared_statements?"},{"location":"DB/Connection.html#DB::Connection#release","text":"return this connection to the pool managed by the database. Should be used only if the connection was obtained by Database#checkout . View source","title":"#release"},{"location":"DB/ConnectionContext.html","text":"module DB::ConnectionContext # Direct including types DB::Database Methods # abstract #discard ( connection : Connection ) # Indicates that the connection was permanently closed and should not be used in the future. View source abstract #prepared_statements? : Bool # Return whether the statements should be prepared by default View source abstract #release ( connection : Connection ) # Indicates that the connection is no longer needed and can be reused in the future. View source abstract #uri : URI # Returns the uri with the connection settings to the database View source","title":"ConnectionContext"},{"location":"DB/ConnectionContext.html#DB::ConnectionContext","text":"","title":"ConnectionContext"},{"location":"DB/ConnectionContext.html#DB::ConnectionContext-methods","text":"","title":"Methods"},{"location":"DB/ConnectionContext.html#DB::ConnectionContext#discard(connection)","text":"Indicates that the connection was permanently closed and should not be used in the future. View source","title":"#discard"},{"location":"DB/ConnectionContext.html#DB::ConnectionContext#prepared_statements?","text":"Return whether the statements should be prepared by default View source","title":"#prepared_statements?"},{"location":"DB/ConnectionContext.html#DB::ConnectionContext#release(connection)","text":"Indicates that the connection is no longer needed and can be reused in the future. View source","title":"#release"},{"location":"DB/ConnectionContext.html#DB::ConnectionContext#uri","text":"Returns the uri with the connection settings to the database View source","title":"#uri"},{"location":"DB/ConnectionLost.html","text":"class DB::ConnectionLost inherits DB::PoolResourceLost # Raised when an established connection is lost probably due to socket/network issues. It is used by the connection pool retry logic. Class methods # .new ( resource : T ) # View source Methods # #connection # View source","title":"ConnectionLost"},{"location":"DB/ConnectionLost.html#DB::ConnectionLost","text":"Raised when an established connection is lost probably due to socket/network issues. It is used by the connection pool retry logic.","title":"ConnectionLost"},{"location":"DB/ConnectionLost.html#DB::ConnectionLost-class-methods","text":"","title":"Class methods"},{"location":"DB/ConnectionLost.html#DB::ConnectionLost.new(resource)","text":"View source","title":".new"},{"location":"DB/ConnectionLost.html#DB::ConnectionLost-methods","text":"","title":"Methods"},{"location":"DB/ConnectionLost.html#DB::ConnectionLost#connection","text":"View source","title":"#connection"},{"location":"DB/ConnectionRefused.html","text":"class DB::ConnectionRefused inherits DB::PoolResourceRefused # Raised when a connection is unable to be established probably due to socket/network or configuration issues. It is used by the connection pool retry logic.","title":"ConnectionRefused"},{"location":"DB/ConnectionRefused.html#DB::ConnectionRefused","text":"Raised when a connection is unable to be established probably due to socket/network or configuration issues. It is used by the connection pool retry logic.","title":"ConnectionRefused"},{"location":"DB/Database.html","text":"class DB::Database inherits Reference # Acts as an entry point for database access. Connections are managed by a pool. Use DB#open to create a Database instance. Refer to QueryMethods and SessionMethods for documentation about querying the database. Database URI # Connection parameters are configured in a URI. The format is specified by the individual database drivers. See the reference book for examples. The connection pool can be configured from URI parameters: initial_pool_size (default 1) max_pool_size (default 0 = unlimited) max_idle_pool_size (default 1) checkout_timeout (default 5.0) retry_attempts (default 1) retry_delay (in seconds, default 1.0) When querying a database, prepared statements are used by default. This can be changed from the prepared_statements URI parameter: prepared_statements (true, or false, default true) Included modules DB::ConnectionContext DB::SessionMethods Methods # #checkout # returns a connection from the pool the returned connection must be returned to the pool by explictly calling Connection#release View source #close # Closes all connection to the database. View source #prepared_statements? : Bool # Return whether the statements should be prepared by default View source #setup_connection ( & proc : Connection -> Nil ) # View source #transaction # yields a Transaction from a connection of the pool Refer to BeginTransaction#transaction for documentation. View source #uri : URI # Returns the uri with the connection settings to the database View source #using_connection # yields a connection from the pool the connection is returned to the pool when the block ends View source","title":"Database"},{"location":"DB/Database.html#DB::Database","text":"Acts as an entry point for database access. Connections are managed by a pool. Use DB#open to create a Database instance. Refer to QueryMethods and SessionMethods for documentation about querying the database.","title":"Database"},{"location":"DB/Database.html#DB::Database--database-uri","text":"Connection parameters are configured in a URI. The format is specified by the individual database drivers. See the reference book for examples. The connection pool can be configured from URI parameters: initial_pool_size (default 1) max_pool_size (default 0 = unlimited) max_idle_pool_size (default 1) checkout_timeout (default 5.0) retry_attempts (default 1) retry_delay (in seconds, default 1.0) When querying a database, prepared statements are used by default. This can be changed from the prepared_statements URI parameter: prepared_statements (true, or false, default true)","title":"Database URI"},{"location":"DB/Database.html#DB::Database-methods","text":"","title":"Methods"},{"location":"DB/Database.html#DB::Database#checkout","text":"returns a connection from the pool the returned connection must be returned to the pool by explictly calling Connection#release View source","title":"#checkout"},{"location":"DB/Database.html#DB::Database#close","text":"Closes all connection to the database. View source","title":"#close"},{"location":"DB/Database.html#DB::Database#prepared_statements?","text":"Return whether the statements should be prepared by default View source","title":"#prepared_statements?"},{"location":"DB/Database.html#DB::Database#setup_connection(&)","text":"View source","title":"#setup_connection"},{"location":"DB/Database.html#DB::Database#transaction(&)","text":"yields a Transaction from a connection of the pool Refer to BeginTransaction#transaction for documentation. View source","title":"#transaction"},{"location":"DB/Database.html#DB::Database#uri","text":"Returns the uri with the connection settings to the database View source","title":"#uri"},{"location":"DB/Database.html#DB::Database#using_connection(&)","text":"yields a connection from the pool the connection is returned to the pool when the block ends View source","title":"#using_connection"},{"location":"DB/Disposable.html","text":"module DB::Disposable # Generic module to encapsulate disposable db resources. Direct including types DB::Connection DB::ResultSet DB::StatementMethods DB::Transaction Methods # #close # Closes this object. View source #closed? # Returns true if this object is closed. See #close . View source","title":"Disposable"},{"location":"DB/Disposable.html#DB::Disposable","text":"Generic module to encapsulate disposable db resources.","title":"Disposable"},{"location":"DB/Disposable.html#DB::Disposable-methods","text":"","title":"Methods"},{"location":"DB/Disposable.html#DB::Disposable#close","text":"Closes this object. View source","title":"#close"},{"location":"DB/Disposable.html#DB::Disposable#closed?","text":"Returns true if this object is closed. See #close . View source","title":"#closed?"},{"location":"DB/Driver.html","text":"abstract class DB::Driver inherits Reference # Database driver implementors must subclass Driver , register with a driver_name using DB#register_driver and override the factory method #build_connection . require \"db\" class FakeDriver < DB :: Driver def build_connection ( context : DB :: ConnectionContext ) FakeConnection . new context end end DB . register_driver \"fake\" , FakeDriver Access to this fake datbase will be available with DB . open \"fake://...\" do | db | # ... use db ... end Refer to Connection , Statement and ResultSet for further driver implementation instructions. Methods # abstract #build_connection ( context : ConnectionContext ) : Connection # View source #connection_pool_options ( params : HTTP :: Params ) # View source","title":"Driver"},{"location":"DB/Driver.html#DB::Driver","text":"Database driver implementors must subclass Driver , register with a driver_name using DB#register_driver and override the factory method #build_connection . require \"db\" class FakeDriver < DB :: Driver def build_connection ( context : DB :: ConnectionContext ) FakeConnection . new context end end DB . register_driver \"fake\" , FakeDriver Access to this fake datbase will be available with DB . open \"fake://...\" do | db | # ... use db ... end Refer to Connection , Statement and ResultSet for further driver implementation instructions.","title":"Driver"},{"location":"DB/Driver.html#DB::Driver-methods","text":"","title":"Methods"},{"location":"DB/Driver.html#DB::Driver#build_connection(context)","text":"View source","title":"#build_connection"},{"location":"DB/Driver.html#DB::Driver#connection_pool_options(params)","text":"View source","title":"#connection_pool_options"},{"location":"DB/DriverSpecs.html","text":"class DB::DriverSpecs(DBAnyType) inherits Reference # Helper class to ensure behaviour of custom drivers require \"db/spec\" DB :: DriverSpecs ( DB :: Any ) . run do # How to connect to database connection_string \"scheme://database_url\" # Clean up database if needed using before/after callbacks before do # ... end after do # ... end # Sample values that will be stored, retrieved across many specs sample_value \"hello\" , \"varchar(25)\" , \"'hello'\" it \"custom spec with a db initialized\" do | db | # assert something using *db* end # Configure the appropiate syntax for different commands needed to run the specs binding_syntax do | index | \"?\" end create_table_1column_syntax do | table_name , col1 | \"create table #{ table_name } ( #{ col1 . name } #{ col1 . sql_type } #{ col1 . null ? \"NULL\" : \"NOT NULL\" } )\" end end The following methods needs to be called to configure the appropiate syntax for different commands and allow all the specs to run: binding_syntax , create_table_1column_syntax , create_table_2columns_syntax , select_1column_syntax , select_2columns_syntax , select_count_syntax , select_scalar_syntax , insert_1column_syntax , insert_2columns_syntax , drop_table_if_exists_syntax . Class methods # .run ( description = \"as a db\" # View source Methods # #after ( & after : -> Nil ) # View source #before ( & before : -> Nil ) # View source #binding_syntax ( & binding_syntax : Proc ( Int32 , String )) # View source #connection_string ( connection_string : String ) # View source #create_table_1column_syntax ( & create_table_1column_syntax : Proc ( String , ColumnDef , String )) # View source #create_table_2columns_syntax ( & create_table_2columns_syntax : Proc ( String , ColumnDef , ColumnDef , String )) # View source #drop_table_if_exists_syntax ( & drop_table_if_exists_syntax : Proc ( String , String )) # View source #encode_null ( encode_null : String ) # View source #insert_1column_syntax ( & insert_1column_syntax : Proc ( String , ColumnDef , String , String )) # View source #insert_2columns_syntax ( & insert_2columns_syntax : Proc ( String , ColumnDef , String , ColumnDef , String , String )) # View source #it ( description = \"assert\" , prepared = :default , file = __FILE__ , line = __LINE__ , end_line = __END_LINE__ , & block : DB::Database -> ) # View source #its # View source #sample_value ( value , sql_type , value_encoded , * , type_safe_value = true ) # Use value as sample value that should be stored in columns of type sql_type . value_encoded is driver specific expression that should generate that value in the database. type_safe_value indicates whether value_encoded is expected to generate the value even without been stored in a table (default true ). View source #select_1column_syntax ( & select_1column_syntax : Proc ( String , ColumnDef , String )) # View source #select_2columns_syntax ( & select_2columns_syntax : Proc ( String , ColumnDef , ColumnDef , String )) # View source #select_count_syntax ( & select_count_syntax : Proc ( String , String )) # View source #select_scalar_syntax ( & select_scalar_syntax : Proc ( String , String? , String )) # View source #support_prepared ( support_prepared : Bool ) # Allow specs that uses prepared statements (default true ) View source #support_unprepared ( support_unprepared : Bool ) # Allow specs that uses unprepared statements (default true ) View source","title":"DriverSpecs"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs","text":"Helper class to ensure behaviour of custom drivers require \"db/spec\" DB :: DriverSpecs ( DB :: Any ) . run do # How to connect to database connection_string \"scheme://database_url\" # Clean up database if needed using before/after callbacks before do # ... end after do # ... end # Sample values that will be stored, retrieved across many specs sample_value \"hello\" , \"varchar(25)\" , \"'hello'\" it \"custom spec with a db initialized\" do | db | # assert something using *db* end # Configure the appropiate syntax for different commands needed to run the specs binding_syntax do | index | \"?\" end create_table_1column_syntax do | table_name , col1 | \"create table #{ table_name } ( #{ col1 . name } #{ col1 . sql_type } #{ col1 . null ? \"NULL\" : \"NOT NULL\" } )\" end end The following methods needs to be called to configure the appropiate syntax for different commands and allow all the specs to run: binding_syntax , create_table_1column_syntax , create_table_2columns_syntax , select_1column_syntax , select_2columns_syntax , select_count_syntax , select_scalar_syntax , insert_1column_syntax , insert_2columns_syntax , drop_table_if_exists_syntax .","title":"DriverSpecs"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs-class-methods","text":"","title":"Class methods"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs.run(description,&)","text":"View source","title":".run"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs-methods","text":"","title":"Methods"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#after(&)","text":"View source","title":"#after"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#before(&)","text":"View source","title":"#before"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#binding_syntax(&)","text":"View source","title":"#binding_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#connection_string(connection_string)","text":"View source","title":"#connection_string"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#create_table_1column_syntax(&)","text":"View source","title":"#create_table_1column_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#create_table_2columns_syntax(&)","text":"View source","title":"#create_table_2columns_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#drop_table_if_exists_syntax(&)","text":"View source","title":"#drop_table_if_exists_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#encode_null(encode_null)","text":"View source","title":"#encode_null"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#insert_1column_syntax(&)","text":"View source","title":"#insert_1column_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#insert_2columns_syntax(&)","text":"View source","title":"#insert_2columns_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#it(description,prepared,file,line,end_line,&)","text":"View source","title":"#it"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#its","text":"View source","title":"#its"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#sample_value(value,sql_type,value_encoded,*,type_safe_value)","text":"Use value as sample value that should be stored in columns of type sql_type . value_encoded is driver specific expression that should generate that value in the database. type_safe_value indicates whether value_encoded is expected to generate the value even without been stored in a table (default true ). View source","title":"#sample_value"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#select_1column_syntax(&)","text":"View source","title":"#select_1column_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#select_2columns_syntax(&)","text":"View source","title":"#select_2columns_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#select_count_syntax(&)","text":"View source","title":"#select_count_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#select_scalar_syntax(&)","text":"View source","title":"#select_scalar_syntax"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#support_prepared(support_prepared)","text":"Allow specs that uses prepared statements (default true ) View source","title":"#support_prepared"},{"location":"DB/DriverSpecs.html#DB::DriverSpecs#support_unprepared(support_unprepared)","text":"Allow specs that uses unprepared statements (default true ) View source","title":"#support_unprepared"},{"location":"DB/Error.html","text":"class DB::Error inherits Exception # Direct known subclasses DB::MappingException DB::NoResultsError DB::PoolResourceLost(T) DB::PoolResourceRefused DB::PoolRetryAttemptsExceeded DB::PoolTimeout DB::Rollback","title":"Error"},{"location":"DB/Error.html#DB::Error","text":"","title":"Error"},{"location":"DB/ExecResult.html","text":"struct DB::ExecResult inherits Struct # Result of a QueryMethods#exec statement. Class methods # .new ( rows_affected : Int64 , last_insert_id : Int64 ) # View source Methods # #clone # View source #copy_with ( rows_affected _rows_affected = @rows_affected , last_insert_id _last_insert_id = @last_insert_id ) # View source #last_insert_id : Int64 # #rows_affected : Int64 #","title":"ExecResult"},{"location":"DB/ExecResult.html#DB::ExecResult","text":"Result of a QueryMethods#exec statement.","title":"ExecResult"},{"location":"DB/ExecResult.html#DB::ExecResult-class-methods","text":"","title":"Class methods"},{"location":"DB/ExecResult.html#DB::ExecResult.new(rows_affected,last_insert_id)","text":"View source","title":".new"},{"location":"DB/ExecResult.html#DB::ExecResult-methods","text":"","title":"Methods"},{"location":"DB/ExecResult.html#DB::ExecResult#clone","text":"View source","title":"#clone"},{"location":"DB/ExecResult.html#DB::ExecResult#copy_with(rows_affected,last_insert_id)","text":"View source","title":"#copy_with"},{"location":"DB/ExecResult.html#DB::ExecResult#last_insert_id","text":"","title":"#last_insert_id"},{"location":"DB/ExecResult.html#DB::ExecResult#rows_affected","text":"","title":"#rows_affected"},{"location":"DB/Field.html","text":"annotation DB::Field #","title":"Field"},{"location":"DB/Field.html#DB::Field","text":"","title":"Field"},{"location":"DB/Mappable.html","text":"module DB::Mappable # Empty module used for marking a class as supporting DB:Mapping","title":"Mappable"},{"location":"DB/Mappable.html#DB::Mappable","text":"Empty module used for marking a class as supporting DB:Mapping","title":"Mappable"},{"location":"DB/MappingException.html","text":"class DB::MappingException inherits DB::Error #","title":"MappingException"},{"location":"DB/MappingException.html#DB::MappingException","text":"","title":"MappingException"},{"location":"DB/MetadataValueConverter.html","text":"module DB::MetadataValueConverter # This module converts DB supported values to ::Log::Metadata::Value Note to implementors # If the driver defines custom types to be used as arguments the default behavior will be converting the value via #to_s . Otherwise you can define overloads to change this behaviour. module DB::MetadataValueConverter def self . arg_to_log ( arg : PG :: Geo :: Point ) :: Log :: Metadata :: Value . new ( \"( #{ arg . x } , #{ arg . y } )::point\" ) end end Class methods # .arg_to_log ( arg : Enumerable ) : :: Log :: Metadata :: Value # Returns arg encoded as a ::Log::Metadata::Value . View source .arg_to_log ( arg : UInt64 ) : :: Log :: Metadata :: Value # Returns arg encoded as a ::Log::Metadata::Value . View source .arg_to_log ( arg : Int ) : :: Log :: Metadata :: Value # Returns arg encoded as a ::Log::Metadata::Value . View source .arg_to_log ( arg : Nil | Bool | Int32 | Int64 | Float32 | Float64 | String | Time ) : :: Log :: Metadata :: Value # Returns arg encoded as a ::Log::Metadata::Value . View source .arg_to_log ( arg ) : :: Log :: Metadata :: Value # Returns arg encoded as a ::Log::Metadata::Value . View source","title":"MetadataValueConverter"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter","text":"This module converts DB supported values to ::Log::Metadata::Value","title":"MetadataValueConverter"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter--note-to-implementors","text":"If the driver defines custom types to be used as arguments the default behavior will be converting the value via #to_s . Otherwise you can define overloads to change this behaviour. module DB::MetadataValueConverter def self . arg_to_log ( arg : PG :: Geo :: Point ) :: Log :: Metadata :: Value . new ( \"( #{ arg . x } , #{ arg . y } )::point\" ) end end","title":"Note to implementors"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter-class-methods","text":"","title":"Class methods"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter.arg_to_log(arg)","text":"Returns arg encoded as a ::Log::Metadata::Value . View source","title":".arg_to_log"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter.arg_to_log(arg)","text":"Returns arg encoded as a ::Log::Metadata::Value . View source","title":".arg_to_log"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter.arg_to_log(arg)","text":"Returns arg encoded as a ::Log::Metadata::Value . View source","title":".arg_to_log"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter.arg_to_log(arg)","text":"Returns arg encoded as a ::Log::Metadata::Value . View source","title":".arg_to_log"},{"location":"DB/MetadataValueConverter.html#DB::MetadataValueConverter.arg_to_log(arg)","text":"Returns arg encoded as a ::Log::Metadata::Value . View source","title":".arg_to_log"},{"location":"DB/NoResultsError.html","text":"class DB::NoResultsError inherits DB::Error # Raised when a scalar query returns no results.","title":"NoResultsError"},{"location":"DB/NoResultsError.html#DB::NoResultsError","text":"Raised when a scalar query returns no results.","title":"NoResultsError"},{"location":"DB/Pool.html","text":"class DB::Pool(T) inherits Reference # Class methods # .new ( initial_pool_size = 1 , max_pool_size = 0 , max_idle_pool_size = 1 , checkout_timeout = 5.0 , retry_attempts = 1 , retry_delay = 0.2 , & factory : -> T ) # View source Methods # #checkout : T # View source #checkout ( & block : T -> ) # View source #checkout_some ( candidates : Enumerable ( WeakRef ( T ))) : Tuple ( T , Bool ) # selected , is_candidate = pool . checkout_some ( candidates ) selected be a resource from the candidates list and is_candidate == true or selected will be a new resource and is_candidate == false View source #close : Nil # close all resources in the pool View source #release ( resource : T ) : Nil # View source #stats # Returns stats of the pool View source","title":"Pool"},{"location":"DB/Pool.html#DB::Pool","text":"","title":"Pool"},{"location":"DB/Pool.html#DB::Pool-class-methods","text":"","title":"Class methods"},{"location":"DB/Pool.html#DB::Pool.new(initial_pool_size,max_pool_size,max_idle_pool_size,checkout_timeout,retry_attempts,retry_delay,&)","text":"View source","title":".new"},{"location":"DB/Pool.html#DB::Pool-methods","text":"","title":"Methods"},{"location":"DB/Pool.html#DB::Pool#checkout","text":"View source","title":"#checkout"},{"location":"DB/Pool.html#DB::Pool#checkout_some(candidates)","text":"selected , is_candidate = pool . checkout_some ( candidates ) selected be a resource from the candidates list and is_candidate == true or selected will be a new resource and is_candidate == false View source","title":"#checkout_some"},{"location":"DB/Pool.html#DB::Pool#close","text":"close all resources in the pool View source","title":"#close"},{"location":"DB/Pool.html#DB::Pool#release(resource)","text":"View source","title":"#release"},{"location":"DB/Pool.html#DB::Pool#stats","text":"Returns stats of the pool View source","title":"#stats"},{"location":"DB/PoolPreparedStatement.html","text":"class DB::PoolPreparedStatement inherits DB::PoolStatement # Represents a statement to be executed in any of the connections of the pool. The statement is not be executed in a prepared fashion. The execution of the statement is retried according to the pool configuration. See PoolStatement Class methods # .new ( db : Database , query : String ) # View source","title":"PoolPreparedStatement"},{"location":"DB/PoolPreparedStatement.html#DB::PoolPreparedStatement","text":"Represents a statement to be executed in any of the connections of the pool. The statement is not be executed in a prepared fashion. The execution of the statement is retried according to the pool configuration. See PoolStatement","title":"PoolPreparedStatement"},{"location":"DB/PoolPreparedStatement.html#DB::PoolPreparedStatement-class-methods","text":"","title":"Class methods"},{"location":"DB/PoolPreparedStatement.html#DB::PoolPreparedStatement.new(db,query)","text":"View source","title":".new"},{"location":"DB/PoolResourceLost.html","text":"class DB::PoolResourceLost(T) inherits DB::Error # Direct known subclasses DB::ConnectionLost Class methods # .new ( resource : T ) # View source Methods # #resource : T # View source","title":"PoolResourceLost"},{"location":"DB/PoolResourceLost.html#DB::PoolResourceLost","text":"","title":"PoolResourceLost"},{"location":"DB/PoolResourceLost.html#DB::PoolResourceLost-class-methods","text":"","title":"Class methods"},{"location":"DB/PoolResourceLost.html#DB::PoolResourceLost.new(resource)","text":"View source","title":".new"},{"location":"DB/PoolResourceLost.html#DB::PoolResourceLost-methods","text":"","title":"Methods"},{"location":"DB/PoolResourceLost.html#DB::PoolResourceLost#resource","text":"View source","title":"#resource"},{"location":"DB/PoolResourceRefused.html","text":"class DB::PoolResourceRefused inherits DB::Error # Direct known subclasses DB::ConnectionRefused","title":"PoolResourceRefused"},{"location":"DB/PoolResourceRefused.html#DB::PoolResourceRefused","text":"","title":"PoolResourceRefused"},{"location":"DB/PoolRetryAttemptsExceeded.html","text":"class DB::PoolRetryAttemptsExceeded inherits DB::Error #","title":"PoolRetryAttemptsExceeded"},{"location":"DB/PoolRetryAttemptsExceeded.html#DB::PoolRetryAttemptsExceeded","text":"","title":"PoolRetryAttemptsExceeded"},{"location":"DB/PoolStatement.html","text":"abstract class DB::PoolStatement inherits Reference # When a statement is to be executed in a DB that has a connection pool a statement from the DB needs to be able to represent a statement in any of the connections of the pool. Otherwise the user will need to deal with actual connections in some point. Included modules DB::StatementMethods Direct known subclasses DB::PoolPreparedStatement DB::PoolUnpreparedStatement Class methods # .new ( db : Database , query : String ) # View source Methods # #exec : ExecResult # See QueryMethods#exec View source #exec ( * args_ , args : Array? = nil ) : ExecResult # See QueryMethods#exec View source #query : ResultSet # See QueryMethods#query View source #query ( * args_ , args : Array? = nil ) : ResultSet # See QueryMethods#query View source #scalar ( * args_ , args : Array? = nil ) # See QueryMethods#scalar View source","title":"PoolStatement"},{"location":"DB/PoolStatement.html#DB::PoolStatement","text":"When a statement is to be executed in a DB that has a connection pool a statement from the DB needs to be able to represent a statement in any of the connections of the pool. Otherwise the user will need to deal with actual connections in some point.","title":"PoolStatement"},{"location":"DB/PoolStatement.html#DB::PoolStatement-class-methods","text":"","title":"Class methods"},{"location":"DB/PoolStatement.html#DB::PoolStatement.new(db,query)","text":"View source","title":".new"},{"location":"DB/PoolStatement.html#DB::PoolStatement-methods","text":"","title":"Methods"},{"location":"DB/PoolStatement.html#DB::PoolStatement#exec","text":"See QueryMethods#exec View source","title":"#exec"},{"location":"DB/PoolStatement.html#DB::PoolStatement#query","text":"See QueryMethods#query View source","title":"#query"},{"location":"DB/PoolStatement.html#DB::PoolStatement#scalar(*,args)","text":"See QueryMethods#scalar View source","title":"#scalar"},{"location":"DB/PoolTimeout.html","text":"class DB::PoolTimeout inherits DB::Error #","title":"PoolTimeout"},{"location":"DB/PoolTimeout.html#DB::PoolTimeout","text":"","title":"PoolTimeout"},{"location":"DB/PoolUnpreparedStatement.html","text":"class DB::PoolUnpreparedStatement inherits DB::PoolStatement # Represents a statement to be executed in any of the connections of the pool. The statement is not be executed in a non prepared fashion. The execution of the statement is retried according to the pool configuration. See PoolStatement Class methods # .new ( db : Database , query : String ) # View source","title":"PoolUnpreparedStatement"},{"location":"DB/PoolUnpreparedStatement.html#DB::PoolUnpreparedStatement","text":"Represents a statement to be executed in any of the connections of the pool. The statement is not be executed in a non prepared fashion. The execution of the statement is retried according to the pool configuration. See PoolStatement","title":"PoolUnpreparedStatement"},{"location":"DB/PoolUnpreparedStatement.html#DB::PoolUnpreparedStatement-class-methods","text":"","title":"Class methods"},{"location":"DB/PoolUnpreparedStatement.html#DB::PoolUnpreparedStatement.new(db,query)","text":"View source","title":".new"},{"location":"DB/QueryMethods.html","text":"module DB::QueryMethods(Stmt) # Methods to allow querying a database. All methods accepts a query : String and a set arguments. Three kind of statements can be performed: 1. #exec waits no record response from the database. An ExecResult is returned. 2. #scalar reads a single value of the response. A union of possible values is returned. 3. #query returns a ResultSet that allows iteration over the rows in the response and column information. Arguments can be passed by position or as an array. db . query ( \"SELECT name FROM ... WHERE age > ?\" , age ) db . query ( \"SELECT name FROM ... WHERE age > ?\" , args : [ age ] ) Convention of mapping how arguments are mapped to the query depends on each driver. Including QueryMethods requires a build(query) : Statement method that is not expected to be called directly. Direct including types DB::SessionMethods(Session, Stmt) DB::SessionMethods::PreparedQuery(Session, Stmt) DB::SessionMethods::UnpreparedQuery(Session, Stmt) Methods # #exec ( query , * args_ , args : Array? = nil ) # Performs the query and returns an ExecResult View source #query ( query , * args_ , args : Array? = nil ) # Executes a query and returns a ResultSet with the results. The ResultSet must be closed manually. result = db . query \"select name from contacts where id = ?\" , 10 begin if result . move_next id = result . read ( Int32 ) end ensure result . close end Note: to use a dynamic list length of arguments use args: keyword argument. result = db . query \"select name from contacts where id = ?\" , args : [ 10 ] View source #query ( query , * args_ , args : Array? = nil # Executes a query and yields a ResultSet with the results. The ResultSet is closed automatically. db . query ( \"select name from contacts where age > ?\" , 18 ) do | rs | rs . each do name = rs . read ( String ) end end View source #query_all ( query , * args_ , args : Array? = nil , as type : Class ) # Executes a query and returns an array where the value of each row is read as the given type . names = db . query_all \"select name from contacts\" , as : String View source #query_all ( query , * args_ , args : Array? = nil , as types : NamedTuple ) # Executes a query and returns an array where each row is read as a named tuple of the given types (the keys of the named tuple are not necessarily the column names). contacts = db . query_all \"select name, age from contacts\" , as : { name : String , age : Int32 } View source #query_all ( query , * args_ , args : Array? = nil , & block : ResultSet -> U ) : Array ( U ) forall U # Executes a query and yield a ResultSet positioned at the beginning of each row, returning an array of the values of the blocks. names = db . query_all \"select name from contacts\" , &. read ( String ) View source #query_all ( query , * args_ , args : Array? = nil , as types : Tuple ) # Executes a query and returns an array where each row is read as a tuple of the given types . contacts = db . query_all \"select name, age from contacts\" , as : { String , Int32 } View source #query_each ( query , * args_ , args : Array? = nil # Executes a query and yields the ResultSet once per each row. The ResultSet is closed automatically. db . query_each \"select name from contacts\" do | rs | puts rs . read ( String ) end View source #query_one ( query , * args_ , args : Array? = nil , & block : ResultSet -> U ) : U forall U # Executes a query that expects a single row and yields a ResultSet positioned at that first row. The given block must not invoke move_next on the yielded result set. Raises DB::NoResultsError if there were no rows. Raises DB::Error if there were more than one row. name = db . query_one \"select name from contacts where id = ?\" , 18 , &. read ( String ) View source #query_one ( query , * args_ , args : Array? = nil , as types : Tuple ) # Executes a query that expects a single row and returns it as a tuple of the given types . Raises DB::NoResultsError if there were no rows. Raises DB::Error if there were more than one row. db . query_one \"select name, age from contacts where id = ?\" , 1 , as : { String , Int32 } View source #query_one ( query , * args_ , args : Array? = nil , as types : NamedTuple ) # Executes a query that expects a single row and returns it as a named tuple of the given types (the keys of the named tuple are not necessarily the column names). Raises DB::NoResultsError if there were no rows. Raises DB::Error if there were more than one row. db . query_one \"select name, age from contacts where id = ?\" , 1 , as : { name : String , age : Int32 } View source #query_one ( query , * args_ , args : Array? = nil , as type : Class ) # Executes a query that expects a single row and returns the first column's value as the given type . Raises DB::NoResultsError if there were no rows. Raises DB::Error if there were more than one row. db . query_one \"select name from contacts where id = ?\" , 1 , as : String View source #query_one? ( query , * args_ , args : Array? = nil , as type : Class ) # Executes a query that expects a single row and returns the first column's value as the given type . Returns nil if there were no rows. Raises DB::Error if there were more than one row. name = db . query_one? \"select name from contacts where id = ?\" , 1 , as : String typeof ( name ) # => String? View source #query_one? ( query , * args_ , args : Array? = nil , as types : NamedTuple ) # Executes a query that expects a single row and returns it as a named tuple of the given types (the keys of the named tuple are not necessarily the column names). Returns nil if there were no rows. Raises DB::Error if there were more than one row. result = db . query_one? \"select name, age from contacts where id = ?\" , 1 , as : { age : String , name : Int32 } typeof ( result ) # => NamedTuple(age: String, name: Int32) | Nil View source #query_one? ( query , * args_ , args : Array? = nil , as types : Tuple ) # Executes a query that expects a single row and returns it as a tuple of the given types . Returns nil if there were no rows. Raises DB::Error if there were more than one row. result = db . query_one? \"select name, age from contacts where id = ?\" , 1 , as : { String , Int32 } typeof ( result ) # => Tuple(String, Int32) | Nil View source #query_one? ( query , * args_ , args : Array? = nil , & block : ResultSet -> U ) : U? forall U # Executes a query that expects at most a single row and yields a ResultSet positioned at that first row. Returns nil , not invoking the block, if there were no rows. Raises DB::Error if there were more than one row (this ends up invoking the block once). name = db . query_one? \"select name from contacts where id = ?\" , 18 , &. read ( String ) typeof ( name ) # => String | Nil View source #scalar ( query , * args_ , args : Array? = nil ) # Performs the query and returns a single scalar value puts db . scalar ( \"SELECT MAX(name)\" ) .as ( String ) # => (a String) View source","title":"QueryMethods"},{"location":"DB/QueryMethods.html#DB::QueryMethods","text":"Methods to allow querying a database. All methods accepts a query : String and a set arguments. Three kind of statements can be performed: 1. #exec waits no record response from the database. An ExecResult is returned. 2. #scalar reads a single value of the response. A union of possible values is returned. 3. #query returns a ResultSet that allows iteration over the rows in the response and column information. Arguments can be passed by position or as an array. db . query ( \"SELECT name FROM ... WHERE age > ?\" , age ) db . query ( \"SELECT name FROM ... WHERE age > ?\" , args : [ age ] ) Convention of mapping how arguments are mapped to the query depends on each driver. Including QueryMethods requires a build(query) : Statement method that is not expected to be called directly.","title":"QueryMethods"},{"location":"DB/QueryMethods.html#DB::QueryMethods-methods","text":"","title":"Methods"},{"location":"DB/QueryMethods.html#DB::QueryMethods#exec(query,*,args)","text":"Performs the query and returns an ExecResult View source","title":"#exec"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query(query,*,args)","text":"Executes a query and returns a ResultSet with the results. The ResultSet must be closed manually. result = db . query \"select name from contacts where id = ?\" , 10 begin if result . move_next id = result . read ( Int32 ) end ensure result . close end Note: to use a dynamic list length of arguments use args: keyword argument. result = db . query \"select name from contacts where id = ?\" , args : [ 10 ] View source","title":"#query"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_all(query,*,args,as)","text":"Executes a query and returns an array where the value of each row is read as the given type . names = db . query_all \"select name from contacts\" , as : String View source","title":"#query_all"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_all(query,*,args,as)","text":"Executes a query and returns an array where each row is read as a named tuple of the given types (the keys of the named tuple are not necessarily the column names). contacts = db . query_all \"select name, age from contacts\" , as : { name : String , age : Int32 } View source","title":"#query_all"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_all(query,*,args,as)","text":"Executes a query and returns an array where each row is read as a tuple of the given types . contacts = db . query_all \"select name, age from contacts\" , as : { String , Int32 } View source","title":"#query_all"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_each(query,*,args,&)","text":"Executes a query and yields the ResultSet once per each row. The ResultSet is closed automatically. db . query_each \"select name from contacts\" do | rs | puts rs . read ( String ) end View source","title":"#query_each"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_one(query,*,args,&)","text":"Executes a query that expects a single row and yields a ResultSet positioned at that first row. The given block must not invoke move_next on the yielded result set. Raises DB::NoResultsError if there were no rows. Raises DB::Error if there were more than one row. name = db . query_one \"select name from contacts where id = ?\" , 18 , &. read ( String ) View source","title":"#query_one"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_one?(query,*,args,as)","text":"Executes a query that expects a single row and returns the first column's value as the given type . Returns nil if there were no rows. Raises DB::Error if there were more than one row. name = db . query_one? \"select name from contacts where id = ?\" , 1 , as : String typeof ( name ) # => String? View source","title":"#query_one?"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_one?(query,*,args,as)","text":"Executes a query that expects a single row and returns it as a named tuple of the given types (the keys of the named tuple are not necessarily the column names). Returns nil if there were no rows. Raises DB::Error if there were more than one row. result = db . query_one? \"select name, age from contacts where id = ?\" , 1 , as : { age : String , name : Int32 } typeof ( result ) # => NamedTuple(age: String, name: Int32) | Nil View source","title":"#query_one?"},{"location":"DB/QueryMethods.html#DB::QueryMethods#query_one?(query,*,args,as)","text":"Executes a query that expects a single row and returns it as a tuple of the given types . Returns nil if there were no rows. Raises DB::Error if there were more than one row. result = db . query_one? \"select name, age from contacts where id = ?\" , 1 , as : { String , Int32 } typeof ( result ) # => Tuple(String, Int32) | Nil View source","title":"#query_one?"},{"location":"DB/QueryMethods.html#DB::QueryMethods#scalar(query,*,args)","text":"Performs the query and returns a single scalar value puts db . scalar ( \"SELECT MAX(name)\" ) .as ( String ) # => (a String) View source","title":"#scalar"},{"location":"DB/ResultSet.html","text":"abstract class DB::ResultSet inherits Reference # The response of a query performed on a Database . See DB for a complete sample. Each #read call consumes the result and moves to the next column. Each column must be read in order. At any moment a #move_next can be invoked, meaning to skip the remaining, or even all the columns, in the current row. Also it is not mandatory to consume the whole ResultSet , hence an iteration through #each or #move_next can be stopped. Note: depending on how the ResultSet was obtained it might be mandatory an explicit call to #close . Check QueryMethods#query . Note to implementors # Override #move_next to move to the next row. Override #read returning the next value in the row. (Optional) Override #read(t) for some types t for which custom logic other than a simple cast is needed. Override #column_count , #column_name . Included modules DB::Disposable Class methods # .new ( statement : DB::Statement ) # View source Methods # abstract #column_count : Int32 # Returns the number of columns in the result View source abstract #column_name ( index : Int32 ) : String # Returns the name of the column in index 0-based position. View source #column_names # Returns the name of the columns. View source #each # Iterates over all the rows View source #each_column # Iterates over all the columns View source abstract #move_next : Bool # Move the next row in the result. Return false if no more rows are available. See #each View source #read ( type : DB :: Mappable . class ) # Reads the next columns and maps them to a class View source #read ( type : T . class ) : T forall T # Reads the next column value as a type View source abstract #read # Reads the next column value View source #read ( * types : Class ) # Reads the next columns and returns a tuple of the values. View source #read ( ** types : Class ) # Reads the next columns and returns a named tuple of the values. View source","title":"ResultSet"},{"location":"DB/ResultSet.html#DB::ResultSet","text":"The response of a query performed on a Database . See DB for a complete sample. Each #read call consumes the result and moves to the next column. Each column must be read in order. At any moment a #move_next can be invoked, meaning to skip the remaining, or even all the columns, in the current row. Also it is not mandatory to consume the whole ResultSet , hence an iteration through #each or #move_next can be stopped. Note: depending on how the ResultSet was obtained it might be mandatory an explicit call to #close . Check QueryMethods#query .","title":"ResultSet"},{"location":"DB/ResultSet.html#DB::ResultSet--note-to-implementors","text":"Override #move_next to move to the next row. Override #read returning the next value in the row. (Optional) Override #read(t) for some types t for which custom logic other than a simple cast is needed. Override #column_count , #column_name .","title":"Note to implementors"},{"location":"DB/ResultSet.html#DB::ResultSet-class-methods","text":"","title":"Class methods"},{"location":"DB/ResultSet.html#DB::ResultSet.new(statement)","text":"View source","title":".new"},{"location":"DB/ResultSet.html#DB::ResultSet-methods","text":"","title":"Methods"},{"location":"DB/ResultSet.html#DB::ResultSet#column_count","text":"Returns the number of columns in the result View source","title":"#column_count"},{"location":"DB/ResultSet.html#DB::ResultSet#column_name(index)","text":"Returns the name of the column in index 0-based position. View source","title":"#column_name"},{"location":"DB/ResultSet.html#DB::ResultSet#column_names","text":"Returns the name of the columns. View source","title":"#column_names"},{"location":"DB/ResultSet.html#DB::ResultSet#each","text":"Iterates over all the rows View source","title":"#each"},{"location":"DB/ResultSet.html#DB::ResultSet#each_column(&)","text":"Iterates over all the columns View source","title":"#each_column"},{"location":"DB/ResultSet.html#DB::ResultSet#move_next","text":"Move the next row in the result. Return false if no more rows are available. See #each View source","title":"#move_next"},{"location":"DB/ResultSet.html#DB::ResultSet#read(type)","text":"Reads the next columns and maps them to a class View source","title":"#read"},{"location":"DB/ResultSet.html#DB::ResultSet#read(type)","text":"Reads the next column value as a type View source","title":"#read"},{"location":"DB/Rollback.html","text":"class DB::Rollback inherits DB::Error #","title":"Rollback"},{"location":"DB/Rollback.html#DB::Rollback","text":"","title":"Rollback"},{"location":"DB/SavePointTransaction.html","text":"class DB::SavePointTransaction inherits DB::Transaction # Class methods # .new ( parent : Transaction , savepoint_name : String ) # View source Methods # #begin_transaction : Transaction # Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source #commit # commits the current transaction View source #connection : Connection # View source #create_save_point_transaction ( parent : Transaction ) # View source #release_from_nested_transaction # View source #rollback # rollbacks the current transaction View source","title":"SavePointTransaction"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction","text":"","title":"SavePointTransaction"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction-class-methods","text":"","title":"Class methods"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction.new(parent,savepoint_name)","text":"View source","title":".new"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction-methods","text":"","title":"Methods"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction#begin_transaction","text":"Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source","title":"#begin_transaction"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction#commit","text":"commits the current transaction View source","title":"#commit"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction#connection","text":"View source","title":"#connection"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction#create_save_point_transaction(parent)","text":"View source","title":"#create_save_point_transaction"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction#release_from_nested_transaction","text":"View source","title":"#release_from_nested_transaction"},{"location":"DB/SavePointTransaction.html#DB::SavePointTransaction#rollback","text":"rollbacks the current transaction View source","title":"#rollback"},{"location":"DB/Serializable.html","text":"module DB::Serializable # The DB::Serialization module automatically generates methods for DB serialization when included. Once included, ResultSet#read(t) populates properties of the class from the ResultSet . Example # require \"db\" class Employee include DB :: Serializable property title : String property name : String end employees = Employee . from_rs ( db . query ( \"SELECT title, name FROM employees\" )) employees [ 0 ]. title # => \"Manager\" employees [ 0 ]. name # => \"John\" Usage # DB::Serializable was designed in analogue with JSON::Serializable , so usage is identical. However, like DB.mapping , DB::Serializable is strict by default , so extra columns will raise DB::MappingException s. Similar to JSON::Field , there is an annotation DB::Field that can be used to set serialization behavior on individual instance variables. class Employee include DB :: Serializable property title : String @[ DB::Field ( key : \"firstname\" ) ] property name : String? end DB::Field properties: * ignore : if true , skip this field in serialization and deserialization ( false by default) * key : defines which column to read from a ResultSet (name of the instance variable by default) * converter : defines an alternate type for parsing results. The given type must define #from_rs(DB::ResultSet) and return an instance of the included type. DB::Serializable::NonStrict # Including this module is functionally identical to passing {strict: false} to DB.mapping : extra columns will not raise. class Employee include DB :: Serializable include DB :: Serializable :: NonStrict property title : String property name : String end # does not raise! employees = Employee . from_rs ( db . query ( \"SELECT title, name, age FROM employees\" )) Class methods # .new ( * , __set_for_db_serializable rs : DB::ResultSet ) # View source","title":"Serializable"},{"location":"DB/Serializable.html#DB::Serializable","text":"The DB::Serialization module automatically generates methods for DB serialization when included. Once included, ResultSet#read(t) populates properties of the class from the ResultSet .","title":"Serializable"},{"location":"DB/Serializable.html#DB::Serializable--example","text":"require \"db\" class Employee include DB :: Serializable property title : String property name : String end employees = Employee . from_rs ( db . query ( \"SELECT title, name FROM employees\" )) employees [ 0 ]. title # => \"Manager\" employees [ 0 ]. name # => \"John\"","title":"Example"},{"location":"DB/Serializable.html#DB::Serializable--usage","text":"DB::Serializable was designed in analogue with JSON::Serializable , so usage is identical. However, like DB.mapping , DB::Serializable is strict by default , so extra columns will raise DB::MappingException s. Similar to JSON::Field , there is an annotation DB::Field that can be used to set serialization behavior on individual instance variables. class Employee include DB :: Serializable property title : String @[ DB::Field ( key : \"firstname\" ) ] property name : String? end DB::Field properties: * ignore : if true , skip this field in serialization and deserialization ( false by default) * key : defines which column to read from a ResultSet (name of the instance variable by default) * converter : defines an alternate type for parsing results. The given type must define #from_rs(DB::ResultSet) and return an instance of the included type.","title":"Usage"},{"location":"DB/Serializable.html#DB::Serializable--dbserializablenonstrict","text":"Including this module is functionally identical to passing {strict: false} to DB.mapping : extra columns will not raise. class Employee include DB :: Serializable include DB :: Serializable :: NonStrict property title : String property name : String end # does not raise! employees = Employee . from_rs ( db . query ( \"SELECT title, name, age FROM employees\" ))","title":"DB::Serializable::NonStrict"},{"location":"DB/Serializable.html#DB::Serializable-class-methods","text":"","title":"Class methods"},{"location":"DB/Serializable.html#DB::Serializable.new(*,__set_for_db_serializable)","text":"View source","title":".new"},{"location":"DB/SessionMethods.html","text":"module DB::SessionMethods(Session, Stmt) # Methods that are shared accross session like objects: - Database - Connection Classes that includes this module are able to execute queries and statements in both prepared and unprepared fashion. This module serves for dsl reuse over session like objects. Included modules DB::QueryMethods Direct including types DB::Connection DB::Database Methods # #build ( query ) : Stmt # :nodoc: View source abstract #build_unprepared_statement ( query ) : Stmt # View source abstract #fetch_or_build_prepared_statement ( query ) : Stmt # View source #prepared ( query ) # Returns a prepared Statement that has not been executed yet. View source #prepared # dsl helper to build prepared statements returns a value that includes QueryMethods View source abstract #prepared_statements? : Bool # Returns whether by default the statements should be prepared or not. View source #unprepared ( query ) # Returns an unprepared Statement that has not been executed yet. View source #unprepared # dsl helper to build unprepared statements returns a value that includes QueryMethods View source","title":"SessionMethods"},{"location":"DB/SessionMethods.html#DB::SessionMethods","text":"Methods that are shared accross session like objects: - Database - Connection Classes that includes this module are able to execute queries and statements in both prepared and unprepared fashion. This module serves for dsl reuse over session like objects.","title":"SessionMethods"},{"location":"DB/SessionMethods.html#DB::SessionMethods-methods","text":"","title":"Methods"},{"location":"DB/SessionMethods.html#DB::SessionMethods#build(query)","text":":nodoc: View source","title":"#build"},{"location":"DB/SessionMethods.html#DB::SessionMethods#build_unprepared_statement(query)","text":"View source","title":"#build_unprepared_statement"},{"location":"DB/SessionMethods.html#DB::SessionMethods#fetch_or_build_prepared_statement(query)","text":"View source","title":"#fetch_or_build_prepared_statement"},{"location":"DB/SessionMethods.html#DB::SessionMethods#prepared(query)","text":"Returns a prepared Statement that has not been executed yet. View source","title":"#prepared"},{"location":"DB/SessionMethods.html#DB::SessionMethods#prepared_statements?","text":"Returns whether by default the statements should be prepared or not. View source","title":"#prepared_statements?"},{"location":"DB/SessionMethods.html#DB::SessionMethods#unprepared(query)","text":"Returns an unprepared Statement that has not been executed yet. View source","title":"#unprepared"},{"location":"DB/Statement.html","text":"abstract class DB::Statement inherits Reference # Represents a query in a Connection . It should be created by QueryMethods . Note to implementors # Subclass Statements Statements are created from a custom driver Connection#prepare method. #perform_query executes a query that is expected to return a ResultSet #perform_exec executes a query that is expected to return an ExecResult #do_close is called to release the statement resources. Included modules DB::StatementMethods Class methods # .new ( connection : Connection , command : String ) # View source Methods # #command : String # View source #exec : DB::ExecResult # See QueryMethods#exec View source #exec ( * args_ , args : Array? = nil ) : DB::ExecResult # See QueryMethods#exec View source #query : DB::ResultSet # See QueryMethods#query View source #query ( * args_ , args : Array? = nil ) : DB::ResultSet # See QueryMethods#query View source #release_connection # View source Macros # def_around_query_or_exec # This macro allows injecting code to be run before and after the execution of the request. It should return the yielded value. It must be called with 1 block argument that will be used to pass the args : Enumerable . class DB:: Statement def_around_query_or_exec do | args | # do something before query or exec res = yield # do something after query or exec res end end View source","title":"Statement"},{"location":"DB/Statement.html#DB::Statement","text":"Represents a query in a Connection . It should be created by QueryMethods .","title":"Statement"},{"location":"DB/Statement.html#DB::Statement--note-to-implementors","text":"Subclass Statements Statements are created from a custom driver Connection#prepare method. #perform_query executes a query that is expected to return a ResultSet #perform_exec executes a query that is expected to return an ExecResult #do_close is called to release the statement resources.","title":"Note to implementors"},{"location":"DB/Statement.html#DB::Statement-class-methods","text":"","title":"Class methods"},{"location":"DB/Statement.html#DB::Statement.new(connection,command)","text":"View source","title":".new"},{"location":"DB/Statement.html#DB::Statement-methods","text":"","title":"Methods"},{"location":"DB/Statement.html#DB::Statement#command","text":"View source","title":"#command"},{"location":"DB/Statement.html#DB::Statement#exec","text":"See QueryMethods#exec View source","title":"#exec"},{"location":"DB/Statement.html#DB::Statement#query","text":"See QueryMethods#query View source","title":"#query"},{"location":"DB/Statement.html#DB::Statement#release_connection","text":"View source","title":"#release_connection"},{"location":"DB/Statement.html#DB::Statement-macros","text":"","title":"Macros"},{"location":"DB/Statement.html#DB::Statement:def_around_query_or_exec(&)","text":"This macro allows injecting code to be run before and after the execution of the request. It should return the yielded value. It must be called with 1 block argument that will be used to pass the args : Enumerable . class DB:: Statement def_around_query_or_exec do | args | # do something before query or exec res = yield # do something after query or exec res end end View source","title":"def_around_query_or_exec"},{"location":"DB/StatementMethods.html","text":"module DB::StatementMethods # Common interface for connection based statements and for connection pool statements. Included modules DB::Disposable Direct including types DB::PoolStatement DB::Statement Methods # abstract #exec : ExecResult # See QueryMethods#exec View source abstract #exec ( * args_ , args : Array? = nil ) : ExecResult # See QueryMethods#exec View source #query ( * args_ , args : Array? = nil # See QueryMethods#query View source abstract #query : ResultSet # See QueryMethods#query View source abstract #query ( * args_ , args : Array? = nil ) : ResultSet # See QueryMethods#query View source #scalar ( * args_ , args : Array? = nil ) # See QueryMethods#scalar View source","title":"StatementMethods"},{"location":"DB/StatementMethods.html#DB::StatementMethods","text":"Common interface for connection based statements and for connection pool statements.","title":"StatementMethods"},{"location":"DB/StatementMethods.html#DB::StatementMethods-methods","text":"","title":"Methods"},{"location":"DB/StatementMethods.html#DB::StatementMethods#exec","text":"See QueryMethods#exec View source","title":"#exec"},{"location":"DB/StatementMethods.html#DB::StatementMethods#query(*,args,&)","text":"See QueryMethods#query View source","title":"#query"},{"location":"DB/StatementMethods.html#DB::StatementMethods#scalar(*,args)","text":"See QueryMethods#scalar View source","title":"#scalar"},{"location":"DB/StringKeyCache.html","text":"class DB::StringKeyCache(T) inherits Reference # Methods # #clear # View source #each_value # View source #fetch ( key : String , & ) : T # View source","title":"StringKeyCache"},{"location":"DB/StringKeyCache.html#DB::StringKeyCache","text":"","title":"StringKeyCache"},{"location":"DB/StringKeyCache.html#DB::StringKeyCache-methods","text":"","title":"Methods"},{"location":"DB/StringKeyCache.html#DB::StringKeyCache#clear","text":"View source","title":"#clear"},{"location":"DB/StringKeyCache.html#DB::StringKeyCache#each_value(&)","text":"View source","title":"#each_value"},{"location":"DB/StringKeyCache.html#DB::StringKeyCache#fetch(key)","text":"View source","title":"#fetch"},{"location":"DB/TopLevelTransaction.html","text":"class DB::TopLevelTransaction inherits DB::Transaction # Class methods # .new ( connection : Connection ) # View source Methods # #begin_transaction : Transaction # Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source #commit # commits the current transaction View source #connection : Connection # View source #rollback # rollbacks the current transaction View source","title":"TopLevelTransaction"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction","text":"","title":"TopLevelTransaction"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction-class-methods","text":"","title":"Class methods"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction.new(connection)","text":"View source","title":".new"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction-methods","text":"","title":"Methods"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction#begin_transaction","text":"Creates a transaction from the current context. If is expected that either Transaction#commit or Transaction#rollback are called explicitly to release the context. View source","title":"#begin_transaction"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction#commit","text":"commits the current transaction View source","title":"#commit"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction#connection","text":"View source","title":"#connection"},{"location":"DB/TopLevelTransaction.html#DB::TopLevelTransaction#rollback","text":"rollbacks the current transaction View source","title":"#rollback"},{"location":"DB/Transaction.html","text":"abstract class DB::Transaction inherits Reference # Transactions should be started from DB#transaction , Connection#transaction or Connection#begin_transaction . Use Transaction#connection to submit statements to the database. Use Transaction#commit or Transaction#rollback to close the ongoing transaction explicitly. Or refer to BeginTransaction#transaction for documentation on how to use #transaction(&block) methods in DB and Connection . Nested transactions are supported by using sql SAVEPOINT . To start a nested transaction use Transaction#transaction or Transaction#begin_transaction . Included modules DB::BeginTransaction DB::Disposable Direct known subclasses DB::SavePointTransaction DB::TopLevelTransaction Methods # #commit # commits the current transaction View source abstract #connection : Connection # View source abstract #release_from_nested_transaction # View source #rollback # rollbacks the current transaction View source","title":"Transaction"},{"location":"DB/Transaction.html#DB::Transaction","text":"Transactions should be started from DB#transaction , Connection#transaction or Connection#begin_transaction . Use Transaction#connection to submit statements to the database. Use Transaction#commit or Transaction#rollback to close the ongoing transaction explicitly. Or refer to BeginTransaction#transaction for documentation on how to use #transaction(&block) methods in DB and Connection . Nested transactions are supported by using sql SAVEPOINT . To start a nested transaction use Transaction#transaction or Transaction#begin_transaction .","title":"Transaction"},{"location":"DB/Transaction.html#DB::Transaction-methods","text":"","title":"Methods"},{"location":"DB/Transaction.html#DB::Transaction#commit","text":"commits the current transaction View source","title":"#commit"},{"location":"DB/Transaction.html#DB::Transaction#connection","text":"View source","title":"#connection"},{"location":"DB/Transaction.html#DB::Transaction#release_from_nested_transaction","text":"View source","title":"#release_from_nested_transaction"},{"location":"DB/Transaction.html#DB::Transaction#rollback","text":"rollbacks the current transaction View source","title":"#rollback"},{"location":"DB/DriverSpecs/ColumnDef.html","text":"struct DB::DriverSpecs::ColumnDef inherits Struct # Class methods # .new ( name : String , sql_type : String , null : Bool ) # View source Methods # #clone # View source #copy_with ( name _name = @name , sql_type _sql_type = @sql_type , null _null = @null ) # View source #name : String # #null : Bool # #sql_type : String #","title":"ColumnDef"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef","text":"","title":"ColumnDef"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef-class-methods","text":"","title":"Class methods"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef.new(name,sql_type,null)","text":"View source","title":".new"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef-methods","text":"","title":"Methods"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef#clone","text":"View source","title":"#clone"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef#copy_with(name,sql_type,null)","text":"View source","title":"#copy_with"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef#name","text":"","title":"#name"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef#null","text":"","title":"#null"},{"location":"DB/DriverSpecs/ColumnDef.html#DB::DriverSpecs::ColumnDef#sql_type","text":"","title":"#sql_type"},{"location":"DB/Pool/Stats.html","text":"struct DB::Pool::Stats inherits Struct # Class methods # .new ( open_connections : Int32 , idle_connections : Int32 , in_flight_connections : Int32 , max_connections : Int32 ) # View source Methods # #clone # View source #copy_with ( open_connections _open_connections = @open_connections , idle_connections _idle_connections = @idle_connections , in_flight_connections _in_flight_connections = @in_flight_connections , max_connections _max_connections = @max_connections ) # View source #idle_connections : Int32 # #in_flight_connections : Int32 # #max_connections : Int32 # #open_connections : Int32 #","title":"Stats"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats","text":"","title":"Stats"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats-class-methods","text":"","title":"Class methods"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats.new(open_connections,idle_connections,in_flight_connections,max_connections)","text":"View source","title":".new"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats-methods","text":"","title":"Methods"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats#clone","text":"View source","title":"#clone"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats#copy_with(open_connections,idle_connections,in_flight_connections,max_connections)","text":"View source","title":"#copy_with"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats#idle_connections","text":"","title":"#idle_connections"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats#in_flight_connections","text":"","title":"#in_flight_connections"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats#max_connections","text":"","title":"#max_connections"},{"location":"DB/Pool/Stats.html#DB::Pool::Stats#open_connections","text":"","title":"#open_connections"},{"location":"DB/Serializable/NonStrict.html","text":"module DB::Serializable::NonStrict #","title":"NonStrict"},{"location":"DB/Serializable/NonStrict.html#DB::Serializable::NonStrict","text":"","title":"NonStrict"},{"location":"DB/SessionMethods/PreparedQuery.html","text":"struct DB::SessionMethods::PreparedQuery(Session, Stmt) inherits Struct # Included modules DB::QueryMethods Class methods # .new ( session : Session ) # View source Methods # #build ( query ) : Stmt # :nodoc: View source","title":"PreparedQuery"},{"location":"DB/SessionMethods/PreparedQuery.html#DB::SessionMethods::PreparedQuery","text":"","title":"PreparedQuery"},{"location":"DB/SessionMethods/PreparedQuery.html#DB::SessionMethods::PreparedQuery-class-methods","text":"","title":"Class methods"},{"location":"DB/SessionMethods/PreparedQuery.html#DB::SessionMethods::PreparedQuery.new(session)","text":"View source","title":".new"},{"location":"DB/SessionMethods/PreparedQuery.html#DB::SessionMethods::PreparedQuery-methods","text":"","title":"Methods"},{"location":"DB/SessionMethods/PreparedQuery.html#DB::SessionMethods::PreparedQuery#build(query)","text":":nodoc: View source","title":"#build"},{"location":"DB/SessionMethods/UnpreparedQuery.html","text":"struct DB::SessionMethods::UnpreparedQuery(Session, Stmt) inherits Struct # Included modules DB::QueryMethods Class methods # .new ( session : Session ) # View source Methods # #build ( query ) : Stmt # :nodoc: View source","title":"UnpreparedQuery"},{"location":"DB/SessionMethods/UnpreparedQuery.html#DB::SessionMethods::UnpreparedQuery","text":"","title":"UnpreparedQuery"},{"location":"DB/SessionMethods/UnpreparedQuery.html#DB::SessionMethods::UnpreparedQuery-class-methods","text":"","title":"Class methods"},{"location":"DB/SessionMethods/UnpreparedQuery.html#DB::SessionMethods::UnpreparedQuery.new(session)","text":"View source","title":".new"},{"location":"DB/SessionMethods/UnpreparedQuery.html#DB::SessionMethods::UnpreparedQuery-methods","text":"","title":"Methods"},{"location":"DB/SessionMethods/UnpreparedQuery.html#DB::SessionMethods::UnpreparedQuery#build(query)","text":":nodoc: View source","title":"#build"}]}